```py
0. 그래프 순회

- visited 백트래킹 x
-> for loop 안에서 모두 해결됨
-> 한 번만 돌리면 되므로

1. 그래프의 연결 여부

- visited 백트래킹 x
- dfs 한 번 돌리면 check가 채워져서 나옴

2. 그래프의 최대깊이?

- visited 백트래킹 o
- 노드 방문할때마다 카운팅 + 1
- dfs 한 번 돌려도 check는 그대로
- 모든 노드를 다 돌려야하므로 check는 매 번 돌릴때마다 초기화가 되어있어야함

3. 싸이클

- 유향 그래프 -> cycle 빈 배열로 놓고 cycle.append 하는 방식이 유리
- 무향 그래프 -> 그냥 내가 만든 코드 쓰자 약간의 오버헤드 있긴 하지만 나쁘지 않음




```

```py # 내가 만든 싸이클 판단 함수

s = set()
def find_cycle(v, prev):
    for ne in node[v]:
        if visited[ne] == 1 and prev != ne: # 이전 노드와 동일하면 안된다 즉 길이가 1인 싸이클은 만들지 않음
            idx = cycle.index(ne)
            s.add(tuple(sorted(cycle[idx:])))
            return
        else:
            if visited[ne] == 0:
                visited[ne] = 1
                cycle.append(ne)
                find_cycle(ne, v)
                visited[ne] = 0 # 백트래킹이 포인트
                cycle.pop() # 백트래킹이 포인트


```

````py

*** 최단경로 ***

1. 다익스트라

-> 한 정점에서 다른 정점간의 최소거리 구할 때
-> 인접리스트 형태의 그래프일 때 적용 가능
-> 단방향 그래프일 때 아마도?
-> 그리디, 우선순위 큐 이용
-> O(ElogV) 보장
-> 헷갈리면 노드 위에 네모 INF를 기억해라

-> **동작 원리**
1) 시작 노드 설정
2) 거리 테이블 초기화
3) 시작정점으로부터 가장 짧은 거리의 노드 선택 -> 시작 노드도 포함
4) 인접 노드 거리(가중치) 업데이트
5) 3,4 반복

# 코드
def dijkstra(start):
  # 시작 노드 설정 및 가중치 테이블 초기화
  heap = []
  heapq.heappush(heap, (0,start)) # 시작정점과의 거리, 현재 노드
  distance[start] = 0

  # 시작 정점으로부터 가장 짧은 노드 선택 -> **시작 노드도 포함**
  while heap:
    dist, now = heapq.heappop(heap)
    if distance[now] < dist: continue # 이미 방문한 정점이라면 건너뛰기

  # *인접노드* 기준으로 가중치 테이블 업데이트
    for nxt in graph[now]:
      next_dist = dist + nxt[1] # dist : 시작 정점과의 거리
      if next_dist < distance[nxt[0]]: # 기존 거리보다 짧다면 업데이트
        distance[nxt[0]] = next_dist
        heapq.heappush(heap, (next_dist, nxt[0]))

dijkstra(start)



2. 플로이드-워셜

-> DP 이용 O(n^3)
-> 모든 정점에서 모든 정점 사이의 최단 경로 구할 때
-> 줄글 문제거나 행렬 격자 문제일 때 적용 가능

```py

기본 형태


n = int(input())
m = int(input())
INF = int(1e9)
graph = [[INF for _ in range(n + 1)] for _ in range(n + 1)]

for i in range(1, n + 1):
  for j in range(1, n + 1):
    if i == j: graph[i][j] = 0

for _ in range(m):
  s, e, c = map(int, input().split())
  # 노드와 노드 사이에 여러 경로가 있을 경우 가장 짧은 것만 채택
  graph[s][e] = min(graph[s][e], c)  # 기존 거리보다 짧은 것이 있다면 갱신

for k in range(1, n + 1):
  for i in range(1, n + 1):
    for j in range(1, n + 1):
      graph[i][j] = min(graph[i][j], graph[i][k] + graph[k][j])

for i in range(1, n + 1):
  for j in range(1, n + 1):
    if graph[i][j] == INF:
      print(0, end=" ")
    else:
      print(graph[i][j], end=" ")
  print()



````

```

```
